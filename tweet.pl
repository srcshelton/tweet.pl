#!/bin/sh
exec perl -wTx $0 "$@"
	if 0;
#!perl -wT
#line 6

package tweet;

use Net::Twitter::Lite::WithAPIv1_1;
use Net::Twitter::Lite::Error;
use Scalar::Util qw( blessed );
use URI::Escape;

use feature qw( switch );

#use Data::Dumper;

# TODO: Read this data from an external configuration file (see also
#       save_tokens and restore_tokens, below).
#
our $account = '<insert account name to DM here>';
our $consumer_key = '<insert consumer key here>';
our $consumer_key_secret = '<insert secret here>';

sub handle_errors( $ );
sub restore_tokens();
sub save_tokens( $$ );
sub main();

sub handle_errors( $ ) {
	my( $error ) = @_;

	if( $error ) {
		if( blessed( $error ) && ( $error -> isa( "Net::Twitter::Lite::Error" ) ) ) {
			given( $error -> code() ) {
				given( /^502$/ ) { $error = "Twitter internal error " . $error -> code() ; }
				given( /^200$/ ) { undef $error; }
			}
			die( "$error\n" ) if( $error );
		} else {
			die(  "Undefined error\n" );
		}
	}
} # handle_errors

sub restore_tokens() {
	# Generated by save_tokens()...
	#
	# TODO: Implementation needed!
	my $at = '<insert Access Token here>';
	my $ats = '<insert Access Token Secret here>';

	return( $at, $ats );
} # restore_tokens

sub save_tokens( $$ ) {
	my( $at, $ats ) = @_;

	# This is a stub...
	#
	# TODO: save_tokens should permanently store the Access Token and
	#       Access Token Secret values (on the local filesystem,
	#       presumably) in a way which can be retrieved by restore_tokens.
	print "Access token: '$at', Access token secret '$ats'\n";
} # save_tokens

sub main() {
	if( 0 == scalar( @ARGV ) or grep( /\b(-h|--help)\b/, @ARGV ) ) {
		print "$0 [--to=<DM recipient>] [--host=<host>] [--type=<direct|update>] [--eventtype=<event>] [message]\n";
		exit 0;
	}

	my $twitter = Net::Twitter::Lite::WithAPIv1_1 -> new(
		  consumer_key     => $consumer_key
		, consumer_secret  => $consumer_key_secret
		, ssl              =>  1
	);

	my( $access_token, $access_token_secret );
	while( not( $twitter -> authorized ) ) {
		# Access Token and Access Token Secret should be stored in a cookie,
		# config file or session database...
		( $access_token, $access_token_secret ) = restore_tokens();
		if( $access_token and $access_token_secret ) {
			$twitter -> access_token( $access_token );
			$twitter -> access_token_secret( $access_token_secret );
		}

		unless( $twitter -> authorized ) {
			# The client is not yet authorized: Do it now
			print "Please authorize this app at " . $twitter -> get_authorization_url . " and enter the PIN below\n";

			print "PIN: ";
			my $pin = <STDIN>; # wait for input
			chomp $pin;

			my( $access_token, $access_token_secret, $user_id, $screen_name ) = $twitter -> request_access_token( verifier => $pin );
			save_tokens( $access_token, $access_token_secret ); # if necessary
		}
	}

	# Twitter is ready...

	eval { $twitter -> verify_credentials(); };
	if ( my $error = $@ ) {
		print Data::Dumper -> Dump( [ $error ], [ qw( *error ) ] );
		if ( blessed( $error ) and ( $error -> isa( "Net::Twitter::Lite::Error" ) ) ) {
			my $code = $error -> code();
			die( "Twitter::Lite API failure: $code\n" ) unless( 200 == $code );
		} else {
			die( "Twitter::Lite API failure\n" );
		}
	}

	# The text below will be prepended to your tweet...
	my $type = "update"; # ... or 'direct'
	my $origin = "unknown";
	my $message = "";
	foreach my $argument ( @ARGV ) {
		if( $argument =~ m/^--to=/ ) {
			$account = $argument;
			$account =~ s/^.*--to=//;
		} elsif( $argument =~ m/^--host=/ ) {
			$origin = $argument;
			$origin =~ s/^.*--host=//;
		} elsif( $argument =~ m/^--type=/ ) {
			$type = $argument;
			$type =~ s/^.*--type=//;
			if( not( ( $type eq 'direct' ) or ( $type eq 'update' ) ) ) {
				die( "Invalid post type '$type' - supported values are 'direct' and 'update'\n" );
			}
		} elsif( $argument =~ m/--eventtype=/ ) {
			$argument =~ s/^.*--eventtype=//;
			$message = "${origin}: ${argument} -${message}";
		} else {
			$message .= " " . $argument;
		}
	}
	# Filter tab characters...
	$message =~ s/\s+/ /g;
	$message =~ s/^ //;

	if( $type eq "direct" ) {
		print "$0: Sending message '$message' to account '$account'\n";
		eval {
			my $response = $twitter -> new_direct_message( { screen_name => $account, text => $message } );
			#print Dumper $response;
		};
		handle_errors( $@ );
	} else {
		warn "$0: Unknown message type '$type'\n" if $type ne "update";
		print "$0: Sending update '$message'\n";
		eval {
			my $response = $twitter -> update( { status => $message } );
			#print Dumper $response;
		};
		handle_errors( $@ );
	}
} # main

main();

exit 0;
