#!/bin/sh
exec perl -wTx $0 "$@"
	if 0;
#!perl -wT
#line 6

package tweet;

use Net::Twitter::Lite::WithAPIv1_1;
use Net::Twitter::Lite::Error;
use Scalar::Util qw( blessed );
use URI::Escape;

# Not actually directly used here, but Net::Twitter::Lite wants it...
use Net::OAuth;

use Data::Dumper;

# TODO: Read this data from an external configuration file (see also
#       save_tokens and restore_tokens, below).
#
our $account = '<insert account name to DM here>';
our $consumer_key = '<insert consumer key here>';
our $consumer_key_secret = '<insert secret here>';

sub handle_errors( $ );
sub restore_tokens();
sub save_tokens( $$ );
sub main();

sub handle_errors( $ ) {
	my( $error ) = @_;

	return( undef ) unless( $error );

	print Data::Dumper -> Dump( [ $error ], [ qw( *error ) ] ) if( $ENV -> { 'DEBUG' } );

	if( blessed( $error ) and ( $error -> isa( "Net::Twitter::Lite::Error" ) ) ) {
		my ( $code, $message );
		eval {
			$code = $error -> code();
			$message = $error -> error();
		};
		if( $code eq 502 ) {
			$message = "Twitter internal error: " . $code . ( defined $error ? " - " . $error -> error() : '' );
		} elsif( $code eq 401 ) {
			$message = "Application not authorised: " . $code . ( defined $error ? " - " . $error -> error() : '' );
		} elsif( $code eq 200 ) {
			return( $code );
		}
		
		die( "FATAL: $message\n" );
	} else {
		die(  "FATAL: Undefined error\n" );
	}
} # handle_errors

sub restore_tokens() {
	# Generated by save_tokens()...
	#
	# TODO: Implementation needed!
	my $at = undef; # insert Access Token here
	my $ats = undef; # insert Access Token Secret here

	return( $at, $ats );
} # restore_tokens

sub save_tokens( $$ ) {
	my( $at, $ats ) = @_;

	# This is a stub...
	#
	# TODO: save_tokens should permanently store the Access Token and
	#       Access Token Secret values (on the local filesystem,
	#       presumably) in a way which can be retrieved by restore_tokens.
	print "Access token: '$at', Access token secret '$ats'\n";
	print "Please now edit the 'restore_tokens' function in '$0' with" .
		"these values\n";
} # save_tokens

sub main() {
	if( 0 == scalar( @ARGV ) or grep( /\b(-h|--help)\b/, @ARGV ) ) {
		print "$0 [--to=<DM recipient>] [--host=<host>] [--type=<direct|update>] [--eventtype=<event>] [message]\n";
		exit 0;
	}

	my $twitter = Net::Twitter::Lite::WithAPIv1_1 -> new(
		  consumer_key     => $consumer_key
		, consumer_secret  => $consumer_key_secret
		, ssl              =>  1
	);

	my( $access_token, $access_token_secret );
	while( not( $twitter -> authorized ) ) {
		# Access Token and Access Token Secret should be stored in a cookie,
		# config file or session database...
		( $access_token, $access_token_secret ) = restore_tokens();
		if( $access_token and $access_token_secret ) {
			$twitter -> access_token( $access_token );
			$twitter -> access_token_secret( $access_token_secret );
		}

		unless( $twitter -> authorized ) {
			# The client is not yet authorized: Do it now
			print "Please authorize this app at " . $twitter -> get_authorization_url . " and enter the PIN below\n";

			print "PIN: ";
			my $pin = <STDIN>; # wait for input
			chomp $pin;

			my( $access_token, $access_token_secret, $user_id, $screen_name ) = $twitter -> request_access_token( verifier => $pin );
			save_tokens( $access_token, $access_token_secret ); # if necessary
		}
	}

	# Twitter is ready...
	eval { $twitter -> verify_credentials(); };
	handle_errors( $@ );

	# The text below will be prepended to the tweet...
	my $type = "update"; # ... or 'direct'
	my $origin = "unknown";
	my $message = "";
	my $haseventtype = undef;
	foreach my $argument ( @ARGV ) {
		if( $argument =~ m/^--to=/ ) {
			$account = $argument;
			$account =~ s/^.*--to=//;
		} elsif( $argument =~ m/^--host=/ ) {
			$origin = $argument;
			$origin =~ s/^.*--host=//;
		} elsif( $argument =~ m/^--type=/ ) {
			$type = $argument;
			$type =~ s/^.*--type=//;
			if( not( ( $type eq 'direct' ) or ( $type eq 'update' ) ) ) {
				die( "Invalid post type '$type' - supported values are 'direct' and 'update'\n" );
			}
		} elsif( $argument =~ m/--eventtype=/ ) {
			$argument =~ s/^.*--eventtype=//;
			$haseventtype = 1;
			$message = "${origin}: ${argument} -${message}";
		} else {
			$message .= " " . $argument;
			$haseventtype = undef;
		}
	}
	# Filter tab characters...
	$message =~ s/\s+/ /g;
	$message =~ s/^ //;
	$message =~ s/ -$// if( $haseventtype );

	my $response;
	if( $type eq "direct" ) {
		print "$0: Sending message '$message' to account '$account'\n";
		eval {
			$response = $twitter -> new_direct_message( { screen_name => $account, text => $message } );
		};
	} else {
		warn "$0: Unknown message type '$type'\n" if $type ne "update";
		print "$0: Sending update '$message'\n";
		eval {
			$response = $twitter -> update( { status => $message } );
		};
	}
	print Data::Dumper -> Dump( [ $response ], [ qw( *response ) ] ) if( $ENV -> { 'DEBUG' } );
	handle_errors( $@ );
} # main

main();

exit 0;

# vi: set syntax=perl:
