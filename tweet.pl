#!/bin/sh
exec perl -wx $0 "$@"
	if 0;
#!perl -w
#line 6

package tweet;
our $name = 'tweet.pl';

use Config::Simple;
use Net::Twitter::Lite::Error;
use Net::Twitter::Lite::WithAPIv1_1;
use Scalar::Util qw( blessed );
use URI::Escape;

# Not actually directly used here, but Net::Twitter::Lite wants it...
use Net::OAuth;

use Data::Dumper;

sub handle_errors( $ );
sub write_initial_config( $;$ );
sub restore_tokens( ;$ );
sub save_tokens( $$;$ );
sub main();

sub handle_errors( $ ) {
	my( $error ) = @_;

	return( undef ) unless( $error );

	print Data::Dumper -> Dump( [ $error ], [ qw( *error ) ] ) if( $ENV -> { 'DEBUG' } );

	if( blessed( $error ) and ( $error -> isa( "Net::Twitter::Lite::Error" ) ) ) {
		my ( $code, $message );
		eval {
			$code = $error -> code();
			$message = $error -> error();
		};
		if( $code eq 502 ) {
			$message = "Twitter internal error: " . $code . ( defined $error ? " - " . $error -> error() : '' );
		} elsif( $code eq 401 ) {
			$message = "Application not authorised: " . $code . ( defined $error ? " - " . $error -> error() : '' );
		} elsif( $code eq 200 ) {
			return( $code );
		}
		
		die( "$0: FATAL: $message\n" );
	} else {
		die(  "$0: FATAL: Undefined error\n" );
	}
} # handle_errors

sub write_initial_config( $;$ ) {
	my( $conf, $values ) = @_;

	return( undef ) unless( defined( $conf ) and length( $conf ) );
	return( undef ) if( defined( $values ) and ( ref( $values ) ne 'HASH' ) );

	warn "$0: INFO: Writing new configuration file '$conf' ...\n";

	my $cs = new Config::Simple( syntax => 'ini' ) or die( "$0: FATAL: Config::Simple() failed: $! ($@)\n" );

	$cs -> param( 'default.dm_account', ( defined $values -> { 'dm_account' } ? $values -> { 'dm_account' } : '<insert account name to DM by default here>' ) );
	$cs -> param( 'keys.consumer_key', ( defined $values -> { 'consumer_key' } ? $values -> { 'consumer_key' } : '<insert Consumer Key value here>' ) );
	$cs -> param( 'keys.consumer_key_secret', ( defined $values -> { 'consumer_key_secret' } ? $values -> { 'consumer_key_secret' } : '<insert Consumer Key Secret value here>' ) );
	$cs -> param( 'tokens.access_token', ( defined $values -> { 'access_token' } ? $values -> { 'access_token' } : '<generated Access Token will be inserted here>' ) );
	$cs -> param( 'tokens.access_token_secret', ( defined $values -> { 'access_token_secret' } ? $values -> { 'access_token_secret' } : '<generated Access Token Secret will be inserted here>' ) );
	$cs -> write( $conf ) or die( "$0: FATAL: Config::Simple::write( '$conf' ) failed: $! ($@)\n" );

	$cs = undef;
} # write_initial_config

sub restore_tokens( ;$ ) {
	my( $cs ) = @_;

	my( $at, $ats );

	# Generated by save_tokens()...
	#
	if( defined( $cs ) ) {
		$at = $cs -> param( 'tokens.access_token' );
		$ats = $cs -> param( 'tokens.access_token_secret' );
	}
	if( not( defined( $at ) and defined( $ats) ) ) {
		$at = '<insert fall-back Access Token value here>';
		$ats = '<insert fall-back Access Token Secret value here>';
	}

	return( $at, $ats );
} # restore_tokens

sub save_tokens( $$;$ ) {
	my( $at, $ats, $cs ) = @_;

	return( undef ) unless( defined( $at ) and defined( $ats ) );

	if( defined( $cs ) ) {
		$cs -> param( 'tokens.access_token', $at );
		$cs -> param( 'tokens.access_token_secret', $ats );
		$cs -> write();

		return 1;
	} else {
		print "Access token: '$at', Access token secret '$ats'\n";
		print "Please now edit the 'restore_tokens' function in '$0' with" .
			"these values\n";

		return 0;
	}
} # save_tokens

sub main() {
	if( 0 == scalar( @ARGV ) or grep( /\b(-h|--help)\b/, @ARGV ) ) {
		print( "$0 [--to=<DM recipient>] [--host=<host>] [--type=<direct|update>] [--eventtype=<event>] [message]\n" );
		exit( 0 );
	}

	my $conf = '/etc/' . $name . '.conf';
	my $home = '/';
	if( exists( $ENV{ 'HOME' } ) ) {
		$home = $ENV{ 'HOME' };
	} else {
		# File::HomeDir would be better, but is an external module :(
		$home = ( getpwuid $> )[7];
	}
	$conf = $home . '/.' . $name . '.conf' unless( ( -e $conf ) and ( -s $conf ) and ( -r $conf ) );
	$conf = $name . '.conf' unless( ( -e $conf ) and ( -s $conf ) and ( -r $conf ) );
	$conf = undef unless( ( -e $conf ) and ( -s $conf ) and ( -r $conf ) );

	if( not( defined( $conf ) ) ) {
		$conf = $home . '/.' . $name . '.conf';

		write_initial_config( $conf );
	}

	print( "$0: INFO: Using configuration file '$conf' ...\n" );

	my $cs = new Config::Simple( $conf );
	my $account = $cs -> param( 'default.dm_account' );
	my $consumer_key = $cs -> param( 'keys.consumer_key' );
	my $consumer_key_secret = $cs -> param( 'keys.consumer_key_secret' );

	my $twitter = Net::Twitter::Lite::WithAPIv1_1 -> new(
		  consumer_key     => $consumer_key
		, consumer_secret  => $consumer_key_secret
		, ssl              =>  1
	);

	my( $access_token, $access_token_secret );
	while( not( $twitter -> authorized ) ) {
		# Access Token and Access Token Secret should be stored in a cookie,
		# config file or session database...
		( $access_token, $access_token_secret ) = restore_tokens( $cs );
		if( $access_token and $access_token_secret ) {
			$twitter -> access_token( $access_token );
			$twitter -> access_token_secret( $access_token_secret );
		}

		unless( $twitter -> authorized ) {
			# The client is not yet authorized: Do it now
			print "Please authorize this app at " . $twitter -> get_authorization_url . " and enter the PIN below\n";

			print "PIN: ";
			my $pin = <STDIN>; # wait for input
			chomp $pin;

			my( $access_token, $access_token_secret, $user_id, $screen_name ) = $twitter -> request_access_token( verifier => $pin );
			save_tokens( $access_token, $access_token_secret, $cs ); # if necessary
		}
	}

	$cs = undef;

	# Twitter is ready...
	eval { $twitter -> verify_credentials(); };
	handle_errors( $@ );

	# The text below will be prepended to the tweet...
	my $type = "update"; # ... or 'direct'
	my $origin = "unknown";
	my $message = "";
	my $haseventtype = undef;
	foreach my $argument ( @ARGV ) {
		if( $argument =~ m/^--to=/ ) {
			$account = $argument;
			$account =~ s/^.*--to=//;
		} elsif( $argument =~ m/^--host=/ ) {
			$origin = $argument;
			$origin =~ s/^.*--host=//;
		} elsif( $argument =~ m/^--type=/ ) {
			$type = $argument;
			$type =~ s/^.*--type=//;
			if( not( ( $type eq 'direct' ) or ( $type eq 'update' ) ) ) {
				die( "$0: FATAL: Invalid post type '$type' - supported values are 'direct' and 'update'\n" );
			}
		} elsif( $argument =~ m/--eventtype=/ ) {
			$argument =~ s/^.*--eventtype=//;
			$haseventtype = 1;
			$message = "${origin}: ${argument} -${message}";
		} else {
			$message .= " " . $argument;
			$haseventtype = undef;
		}
	}
	# Filter tab characters...
	$message =~ s/\s+/ /g;
	$message =~ s/^ //;
	$message =~ s/ -$// if( $haseventtype );

	my $response;
	if( $type eq "direct" ) {
		die( "$0: FATAL: No account specified for DM in config file or on command-line\n" ) unless( defined( $account ) and length( $account ) );

		print "$0: Sending message '$message' to account '$account'\n";
		eval {
			$response = $twitter -> new_direct_message( { screen_name => $account, text => $message } );
		};
	} else {
		warn "$0: Unknown message type '$type'\n" if $type ne "update";
		print "$0: Sending update '$message'\n";
		eval {
			$response = $twitter -> update( { status => $message } );
		};
	}
	print Data::Dumper -> Dump( [ $response ], [ qw( *response ) ] ) if( $ENV -> { 'DEBUG' } );
	handle_errors( $@ );
} # main

main();

exit( 0 );

# vi: set syntax=perl:
