#!/bin/sh
exec perl -wTx $0 "$@"
	if 0;
#!perl -wT
#line 6

package tweet;
our $name = 'tweet.pl';

use Config::Simple;
use Net::Twitter::Lite::Error;
use Net::Twitter::Lite::WithAPIv1_1;
use Scalar::Util qw( blessed );
use URI::Escape;

# Not actually directly used here, but Net::Twitter::Lite wants it...
use Net::OAuth;

use Data::Dumper;

use constant DEBUG => defined( $ENV{ 'DEBUG' } and length( $ENV{ 'DEBUG' } ) );
use constant SIMULATE => defined( $ENV{ 'notweet' } and length( $ENV{ 'notweet' } ) );

sub handle_errors( $ );
sub write_initial_config( $;$ );
sub restore_tokens( ;$$ );
sub save_tokens( $$;$ );
sub main();

sub handle_errors( $ ) {
	my( $error ) = @_;

	return( undef ) unless( $error );

	print Data::Dumper -> Dump( [ $error ], [ qw( *error ) ] ) if( $ENV -> { 'DEBUG' } );

	if( blessed( $error ) and ( $error -> isa( "Net::Twitter::Lite::Error" ) ) ) {
		my ( $code, $message );
		eval {
			$code = $error -> code();
			$message = $error -> error();
		};
		if( $code eq 502 ) {
			$message = "Twitter internal error: " . $code . ( defined $error ? " - " . $error -> error() : '' );
		} elsif( $code eq 401 ) {
			$message = "Application not authorised: " . $code . ( defined $error ? " - " . $error -> error() : '' );
		} elsif( $code eq 200 ) {
			return( $code );
		}
		
		die( "$name: FATAL: $message\n" );
	} else {
		die(  "$name: FATAL: Undefined error\n" );
	}
} # handle_errors

sub write_initial_config( $;$ ) {
	my( $conf, $values ) = @_;

	return( undef ) unless( defined( $conf ) and length( $conf ) );
	return( undef ) if( defined( $values ) and ( ref( $values ) ne 'HASH' ) );

	warn "$name: INFO:  Writing new configuration file '$conf' ...\n";

	my $cs = new Config::Simple( syntax => 'ini' ) or die( "$name: FATAL: Config::Simple() failed: $! ($@)\n" );

	$cs -> param( 'default.dm_account', ( defined $values -> { 'dm_account' } ? $values -> { 'dm_account' } : '<insert account name to DM by default here>' ) );
	$cs -> param( 'keys.consumer_key', ( defined $values -> { 'consumer_key' } ? $values -> { 'consumer_key' } : '<insert Consumer Key value here>' ) );
	$cs -> param( 'keys.consumer_key_secret', ( defined $values -> { 'consumer_key_secret' } ? $values -> { 'consumer_key_secret' } : '<insert Consumer Key Secret value here>' ) );
	$cs -> param( 'tokens.access_token', ( defined $values -> { 'access_token' } ? $values -> { 'access_token' } : '<generated Access Token will be inserted here>' ) );
	$cs -> param( 'tokens.access_token_secret', ( defined $values -> { 'access_token_secret' } ? $values -> { 'access_token_secret' } : '<generated Access Token Secret will be inserted here>' ) );

	# Apparently, $conf is considered tainted...
	$conf =~ /^(.*)$/; $conf = $1;

	if( not( DEBUG ) ) {
		$cs -> write( $conf ) or die(
			"$name: FATAL: Config::Simple::write( '$conf' )" .
				" failed: $! ($@)\n"
		);
	}

	warn "An initial configuration file has been written to '$conf'.\n";
	warn "Please now edit this file and and insert your Twitter" .
		" Consumer Key and Access Secret.\n";
	warn "Once these values are populated, please re-run $name to send" .
		" messages.\n";

	exit( 1 ) unless DEBUG;

	$cs = undef;
} # write_initial_config

sub restore_tokens( ;$$ ) {
	my( $cs, $conf ) = @_;

	my( $at, $ats );

	# Generated by save_tokens()...
	#
	if( defined( $cs ) ) {
		$at = $cs -> param( 'tokens.access_token' );
		$ats = $cs -> param( 'tokens.access_token_secret' );

		if( $at =~ m/^<.*>$/ or $ats =~ m/^<.*>$/ ) {
			warn "$name: FATAL: Read invalid Access Token or" .
				" Access Token Secret\n";
			if( defined( $conf ) and length( $conf ) ) {
				die "$name: FATAL: Please check '$conf' and" .
					" enter your account-specific" .
					" values\n";
			} else {
				die "$name: FATAL: Please check your" .
					" configuration file and enter your" .
					" account-specific values\n";
			}
		}
	}
	if( not( defined( $at ) and defined( $ats) ) ) {
		$at = '<insert fall-back Access Token value here>';
		$ats = '<insert fall-back Access Token Secret value here>';
	}

	return( $at, $ats );
} # restore_tokens

sub save_tokens( $$;$ ) {
	my( $at, $ats, $cs ) = @_;

	return( undef ) unless( defined( $at ) and defined( $ats ) );

	if( defined( $cs ) ) {
		$cs -> param( 'tokens.access_token', $at );
		$cs -> param( 'tokens.access_token_secret', $ats );
		$cs -> write();

		return( 1 );
	} else {
		print "Access token: '$at', Access token secret '$ats'\n";
		print "Please now edit the 'restore_tokens' function in '$name' with" .
			"these values\n";

		return( 0 );
	}
} # save_tokens

sub main() {
	if( 0 == scalar( @ARGV ) or grep( /\b(-h|--help)\b/, @ARGV ) ) {
		print( "$name [--to=<DM recipient>] [--host=<host>] [--type=<direct|update>] [--eventtype=<event>] [message]\n" );
		exit( 0 );
	}

	my $conf = '/etc/' . $name . '.conf';
	my $home = '/';
	if( exists( $ENV{ 'HOME' } ) ) {
		$home = $ENV{ 'HOME' };
	} else {
		# File::HomeDir would be better, but is an external module :(
		$home = ( getpwuid $> )[7];
	}
	$conf = $home . '/.' . $name . '.conf' unless( ( -e $conf ) and ( -s $conf ) and ( -r $conf ) );
	$conf = $name . '.conf' unless( ( -e $conf ) and ( -s $conf ) and ( -r $conf ) );
	$conf = undef unless( ( -e $conf ) and ( -s $conf ) and ( -r $conf ) );

	if( not( defined( $conf ) ) ) {
		$conf = $home . '/.' . $name . '.conf';

		write_initial_config( $conf );
	}

	print( "$name: INFO:  Using configuration file '$conf' ...\n" );

	my $cs = new Config::Simple( $conf );
	my $account = $cs -> param( 'default.dm_account' );
	my $consumer_key = $cs -> param( 'keys.consumer_key' );
	my $consumer_key_secret = $cs -> param( 'keys.consumer_key_secret' );

	if( $consumer_key =~ m/^<.*>$/ or $consumer_key_secret =~ m/^<.*>$/ ) {
		warn "$name: FATAL: Read invalid Consumer Key or Consumer" .
			" Key Secret\n";
		if( defined( $conf ) and length( $conf ) ) {
			die "$name: FATAL: Please check '$conf' and enter" .
				" your account-specific values\n";
		} else {
			die "$name: FATAL: Please check your configuration" .
				" file and enter your account-specific values\n";
		}
	}

	my $twitter = Net::Twitter::Lite::WithAPIv1_1 -> new(
		  consumer_key     => $consumer_key
		, consumer_secret  => $consumer_key_secret
		, ssl              =>  1
	);

	my( $access_token, $access_token_secret );
	while( not( $twitter -> authorized ) ) {
		# Access Token and Access Token Secret should be stored in a cookie,
		# config file or session database...
		( $access_token, $access_token_secret ) = restore_tokens( $cs, $conf );
		if( $access_token and $access_token_secret ) {
			$twitter -> access_token( $access_token );
			$twitter -> access_token_secret( $access_token_secret );
		}

		unless( $twitter -> authorized ) {
			# The client is not yet authorized: Do it now
			print "Please authorize this app at " . $twitter -> get_authorization_url . " and enter the PIN below\n";

			print "PIN: ";
			my $pin = <STDIN>; # wait for input
			chomp $pin;

			my( $access_token, $access_token_secret, $user_id, $screen_name ) = $twitter -> request_access_token( verifier => $pin );
			save_tokens( $access_token, $access_token_secret, $cs ); # if necessary
		}
	}

	$cs = undef;

	# Twitter is ready...
	eval { $twitter -> verify_credentials(); };
	handle_errors( $@ );

	# The text below will be prepended to the tweet...
	my $type = "update"; # ... or 'direct'
	my $origin = "unknown";
	my $message = "";
	my $haseventtype = undef;
	my $nextarg = undef;

	warn "$name: DEBUG: Processing " . scalar( @ARGV ) . " arguments ...\n" if DEBUG;

	foreach my $argument ( @ARGV ) {
		if( $nextarg and length( $nextarg ) ) {
			$argument = "$nextarg=$argument";
			warn "$name: DEBUG: Restoring argument '$argument' ...\n" if DEBUG;
			$nextarg = undef;
		}

		if( $argument =~ m/^--to=?/ ) {
			if( $argument eq '--to' ) {
				$nextarg = $argument;
			} else {
				$account = $argument;
				$account =~ s/^.*--to=//;
				warn "$name: DEBUG: Sending tweet to account '$account' ...\n" if DEBUG;
			}

		} elsif( $argument =~ m/^--host=?/ ) {
			if( $argument eq '--host' ) {
				$nextarg = $argument;
			} else {
				$origin = $argument;
				$origin =~ s/^.*--host=//;
				warn "$name: DEBUG: Using host/prefix '$origin' ...\n" if DEBUG;
			}

		} elsif( $argument =~ m/^--type=?/ ) {
			if( $argument eq '--type' ) {
				$nextarg = $argument;
			} else {
				$type = $argument;
				$type =~ s/^.*--type=//;
				if( not( ( $type eq 'direct' ) or ( $type eq 'update' ) ) ) {
					die( "$name: FATAL: Invalid post type '$type' - supported values are 'direct' and 'update'\n" );
				}
				warn "$name: DEBUG: Sending tweet of type '$type' ...\n" if DEBUG;
			}

		} elsif( $argument =~ m/--eventtype=?/ ) {
			if( $argument eq '--eventtype' ) {
				$nextarg = $argument;
			} else {
				$argument =~ s/^.*--eventtype=//;
				$haseventtype = 1;
				$message = "${origin}: ${argument} -${message}";
				warn "$name: DEBUG: Found event type '$argument' for message: unfiltered text is now '$message'.\n" if DEBUG;
			}

		} else {
			if( $message and length( $message ) ) {
				$message .= " " . $argument;
			} else {
				$message = $argument;
			}
			$haseventtype = undef;
			warn "$name: DEBUG: Found no event type for message: unfiltered text is now '$message'.\n" if DEBUG;
		}
	}
	# Filter tab characters...
	$message =~ s/\s+/ /g;
	$message =~ s/^ //;
	$message =~ s/ -$// if( $haseventtype );
	warn "$name: DEBUG: Filtered message is '$message'.\n" if DEBUG;

	my $response;
	if( $type eq "direct" ) {
		die( "$name: FATAL: No account specified for DM in config file or on command-line\n" ) unless( defined( $account ) and length( $account ) );
		die( "$name: FATAL: Invalid account '$account' specified for DM in config file or on command-line\n" ) if( $account =~ m/^<.*>$/ );

		print "$name: INFO:  " . ( SIMULATE ? 'Simulating s' : 'S' ) . "ending message '$message' to account '$account'\n";
		eval {
			$response = $twitter -> new_direct_message( { screen_name => $account, text => $message } );
		} if( not( SIMULATE ) );
	} else {
		warn "$name: WARN:  Unknown message type '$type' - sending as 'update' ...\n" if $type ne "update";
		print "$name: INFO:  " . ( SIMULATE ? 'Simulating s' : 'S' ) . "ending update '$message'\n";
		eval {
			$response = $twitter -> update( { status => $message } );
		} if( not( SIMULATE ) );
	}
	if( not( SIMULATE ) ) {
		print Data::Dumper -> Dump( [ $response ], [ qw( *response ) ] ) if( $ENV -> { 'DEBUG' } );
		handle_errors( $@ );
	}
} # main

main();

exit( 0 );

# vi: set syntax=perl:
